# Security

Security is baked into the core of NDN, and is a fundamental part of the architecture. NDN utilizes a data-centric name-based security model, where all data is signed by the producer of the data. This allows NDN to effectively support a data-centric security and trust model. The following sections provide an overview of the security features of NDN.

## Signature

In NDN, all data is digitally signed by its producer.
The signature guarantees the _integrity_ of the packet, because the signature can only be generated by the original producer, and becomes invalid if the encoded packet is modified.

Digital signing is done by a pair of asymmetric keys, which consists of a private key and a public key.
The _private key_ is known only by the producer, used to generate signatures.
Anyone who knows the _public key_ can verify the signature.


=== "python-ndn"

    ``` python
    --8<-- "snippets/security/key-gen.py"
    ```

=== "NDNts"

    ``` typescript
    --8<-- "snippets/security/key-gen.ts"
    ```


In a system, security is more than cryptographically verifying the signature.
For example, we also need to

-   Securely obtain the public key of the producer.
    -   A signed piece of data containing the pubic key is called a _certificate_.
-   Associate the producer with a member (human or process) in the system.
-   Make sure the member is allowed to sign the data.

These tasks can be roughly classified into four aspects:

-   Bootstrapping: to enroll a new member into an application. Make sure that the new member learns necessary security information to recognize others, and the other members are able to securely recognize new member.
-   Management: to manage the membership and certificates, including certification revocation, renewal, and other operations.
-   Authentication: to verify a piece of data is produced by claimed producer and not manipulated by an impersonator.
    This includes cryptographically verifying the signature.
-   Authorization: a piece of data is produced by an intended producer, and accessed by an intended consumer.
    This includes discarding of data whose producers are not allowed to produce, and encrypting data so that only permitted consumers can decrypt.

The classification described is not strict. Most work on NDN involves more than one aspects of the security.

## Trust Domain

A _trust domain_ is a collection of named entities under the same administrative control.
For example, if a research group uses some NDN software to write papers,
then the papers and users' certificates involved in that software makes a trust domain.

A trust zone is usually configured with a _trust anchor_, a self-signed certificate whose name prefix reflects the name of the trust domain.
The trust anchor is called an "anchor" because all trust relations in the domain starts from it.
Suppose in the above paper writing example, the professor uses an admin certificate to sign student's public key,
and students uses their own key to sign changes they make to the paper.
Then, we have the following chain of signing:

``` mermaid
flowchart LR
    Admin -->|signs| Student -->|signs| paper[Paper Changes]
```

All signatures start from the admin's certificate if we transitively follow the chain of signing.
The entity (member or process) that owns the trust anchor has the power to control all trust relations within the trust domain.
Entities managing the trust relationship of the trust domain (including memberships and roles) are called _controllers_.
The owner of the trust anchor is always a controller.

=== "python-ndn"

    ``` python
    --8<-- "snippets/security/trust-domain.py"
    ```

=== "NDNts"

    ``` typescript
    --8<-- "snippets/security/trust-domain.ts"
    ```

An application may involve multiple trust domains. _Inter-domain trust relations_ will be established by the controller.
In the case where pure peer-to-peer trust relation is established, every member is its own controller.

!!! info "Trust Zone"

    A trust domain has also been called a _trust zone_ in some papers, not to be confused with the hardware trust zone.

## Trust Schema

TBD

## Full Name

The _full name_ of a Data packet is the name of the Data appended with a ImplicitSha256Digest component.
The digest component contains a SHA256 hash of the whole packet.
Therefore, if the consumer securely obtains the full name of a packet, it can verifies the integrity by simply computing its hash digest,
without knowing any key.

This is useful for bootstrapping: one can learn the full name of the new member's certificate out-of-band,
and then fetch the it through some non-secure channel.

(Code snippet to be added)
